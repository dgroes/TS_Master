### Drag and Drop
Drag and Drop es el hecho de arrastrar (**drag**) y soltar (**drop**) un elemento (**draggable**) sobre otro elemento (**drop zone**) en una interfaz de usuario.

### Draggalbe
Para hacer un elemento arrastable, hay un atributo en HTML que se llama "draggable", a√±adiendolo a un elemento se convierte en un elmeneto que se puede arrastrar, para ello adem√°s deber√° estar su valor en true
`draggable	Con el valor true, convierte el elemento en arrastrable.`

Ejemplo:

`<article id="hola" draggable="true">...`
Ahora este elmenento `<article>` es arrastable

Por defecto, algunos elementos como las im√°genes ``<img>`` ya son arrastrables y no requieren este atributo, sin embargo, otras como un simple ``<div>`` no lo son.

Para converitr un elemento en arrastable desde TS, se puede hacer de la siguiente forma:
```
const dragItem = document.getElementById("hola") as HTMLElement;
dragItem.draggable = true;

```

### DropZone
Ser√°n las √°reas en las que se acepten elmentos arrastrados, esta require un `ondragover` + `event.preventDefault()` para permitri el drop. Adem√°s un `ondrop` para procesar los datos del elemento soltado.

```typescript
interface Dropzone {
  ondragover: (event: DragEvent) => void; // Permite soltar (preventDefault)
  ondrop: (event: DragEvent) => void; // Maneja el elemento soltado
}
```

### Eventos Drag & Drop
Para personalizar nuestro sistema Drag and Drop necesitamos utilizar ciertos eventos de Javascript. Primero hablaremos de los eventos de arrastre (Drag), luego de los eventos de soltar (Drop) y por √∫ltimo comentaremos el objeto .dataTransfer.


### C01: Variable para almacenar el elemento que se est√° arrastrando
Se declara una variable que guardar√° **temporalmente el elemento** que est√° siendo arrastrado.
Es `null` por defecdto porque a√∫n no se ha arrastrado nada.
Se usa para que al momento del `drop` sepamos qu√© elemento mover

### C02: Seleccionar elementos que se pueden arrastrar
Esta l√≠nea hace que busca en el DOM todoso los elementos con la clase `.draggable`. Adem√°s se asume que esos `<div>` tienen el atributo de `draggable="true"` en el HTML. Luego, para cada uno, se les agrega un listener

#### `el.addEventListener("dragstart", (e) => {`:

Sin esta l√≠nea TS, se nos quejar√° diciendo: "*La propiedad 'dataTransfer' no existe en el tipo 'Event'*", debdio a esto es necesario realizar esta l√≠nea

- Lo que hace: Cuando alguien comience a arrastrar este elemento (`el`), ejecuta esta funci√≥n
- Se activa cuando el usuario empieza a arrastrar un elemento.
- `e` es el evento DragEvent.
- (`e`): Esta es una funci√≥n anonima que se ejectura cuando ocurre el eveneto `"draggstart"`
- `e`: Es una variable que representa el evento que ocrruri√≥. En este caso ser√° un `DragEvent`.
- Cundo se empiece arrastrar (`dragstrat`), el navegador ejecuta la funci√≥n, y pasa como par√°metro el evento de arrastre, que el usuario captura como `e`.

Con `const even = ...` Almacenamos ese valor en una nueva constante `event`, pero ahora con el tipo correcto `DragEvent`, lo que nos permitir√° acceder a propiedades especificas como `.dataTransfer`. 


#### `const event = e as DragEvent;`
Entonces, `e` es el objeto que representa el evento que ocurri√≥n (el navegador lo pas√≥ a la funci√≥n autom√°ticamente).

Luego `as DragEvent`: Le decimos a TS que `e` es enrealidad un `DragEvent,` un que el tipo por defecto puede ser solo Event. En TS ser√° necesario dejarlo explicito



#### `draggedElement = el as HTMLElement;`:
- Se guarda en la variable `draggedElement` una referencia directa al elemento que se est√° arrastrando.
- El `as HTMLElement` indica al compilador de TS que el `el` es un elemento HTML v√°lido.

#### `event.dataTransfer?.setData("text/plain", "");`
- Algunos navegadores (especialmente Firefox) requieren que se llame a setData() para que el drag funcione.
- Aunque no pasamos datos √∫tiles aqu√≠ (cadena vac√≠a), permite que el navegador sepa que se est√° arrastrando algo.

### C03: Zonas en donde soltar elementos
Con la l√≠nea: `document.querySelectorAll(".dropzone").forEach(zone => {`, le indicamos:
- Selecciona todos los elementos del DOM que tienen la clase `dropzone`
- Con el `.forEach(zone => { ... })` se le indica que recorra cada uno de esos elementos y que ejecute una funci√≥n para asignarles eventos relacionados con el drop & drap
- `zone` ser√° el nombre de la variable que se usar√° dentro de la funci√≥n flecha (foreach) para luego poder referirse a cada uno de los elementos seleccionados por `document.querySelectorAll(".dropzone")`


```typescript
    zone.addEventListener("dragover", (e) => {
        e.preventDefault(); // Necesario para permitir el drop
    });
```
üëÜ
Con est√° parte del c√≥digo le digo a todos los elementos con clase `dropzone`, les estoy diciendo que cuando un elemento est√© siento arrastrado sobre ellos (`dragover`), permitan que se suelte (`drop`) llamando a `preventDefault()`. Etonces: 
- `zone`: Es cada uno de los elementos con la clase `.dropzone` (por ejemplo, un `<article>` o `<section>` dondo se puede soltar elementos).
- Aqu√≠ el `dragover` es un evento que se dispara continuamente mientras un elemento arrastrable pasa por encima del contenedor (`zone`).
- `e.preventDefault()`: Por defecto, muchos navegadores *no permiten soltar elementos*. Llamar a `preventDefault()` aqu√≠ es **obligatorio** para que el `drop` funcione correctamente. (Si no se llama a preventDefault() en dragover, el evento drop nunca se disparar√°, aunque su listener est√© definido.)


```typescript
    zone.addEventListener("drop", (e) => {
        e.preventDefault();      
```
üëÜ
Con est√° l√≠nea estamos diciendo al navegador: "Oye, si alguien suelta un elemento dentro del contenedor (zone), haz alog". Ese algo es lo siguiente de las l√≠neas de c√≥digo.
- `zone` representa un contenedor donde se pueden soltar cosas, como por ejemplo un `<article>` o `<section>` con la clase .dropzone.`
- `addEventListener("drop", ...)` le est√° diciendo al navegador es: ‚ÄúEscucha si algo es soltado (drop) dentro de este elemento.‚Äù
- `drop`: Se activa cuando se suelta un elemento arrastrado encima del zone.
- `e.preventDefault()`: Se usa nuevamente para evitar cualquier comportamiento por defecto del navegador (como abrir un enlace si arrastras y sueltas uno, por ejemplo).


```typescript
        if (draggedElement) {
            zone.appendChild(draggedElement);
            draggedElement = null;
        }
```
üëÜ
Con esas l√≠neas se asegura que haya algo arrastrado (`draggedElement`), que lo mueve al nuevo contenedor(`zone`) y que **resetea** la variable dej√°ndola en `null` para futuras operaciones.
- `if (draggedElement)`: Si `draggElemento` no es null ni undefined, haz esto...
- `if (draggedElement)`: Verifica si hay un elemento que se est√° arrastrando. Esta variable deber√≠a hacer sido definida globalmente antes del evento `dragstart`.
-`zone.appendChild(draggedElement)`: Mueve el elemento arrastrado al contenedor (`zone`) actual. Esto realiza el movimiento en el DOM. Entonces esto es lo que mueve visualemnte el elemento arrastrado (`draggesElement`) dentro del contenedor `zone`. Se hace uso del `appendChild` para colocarlo com hijo del elemento que act√∫a como zona de drop.
-`draggedElement = null`: Limpia la variable para evitar conflictos con futuros eventos de arrastre. por lo que hace m√°s o menos esto: "Ya que terminamos de mover el elemento, limpiamos la variable `draggedElement` para que no siga apuntando a ese elemento".
- El uso del `draggedElement = null` es una buena pr√°ctica porqu√© evita errores si alguien intenta arrastrar de nuevo y la varible tiene un valor antiguo y permite que el sistema est√© listo para un pr√≥xima operaci√≥n de drag & drop limpia.

### C04: Comportamiento por Defecto (preventDefault())
El m√©todo `preventDefault()` evita el comportamiento por defecto de un evento en JS. En este caso del formulario, su comportamiento por defecto es:
- Recargar la p√°gina al hacer submit.
- Evitar los datos a la URL especificada en el atributo action

- Sin `prevent`: La p√°ginas se recargar√≠a inmediatemente despues del submit, borrando todos los datos en memoria y evitando que se ejecuten `addTask` y `rederTask`
- Con `prevent`: La p√°gina **no se recarga**, permitiendo que el c√≥digo JS maneje los datos del formulario

### 05 Validaci√≥n b√°sica
El uso de esta l√≠nea es para que:
- El campo `title` no est√© vac√≠o (despues de eliminar los espacios con el `.trim`)
- Si est√° vacio (""), el c√≥digo no continua, el `return` detiene la ejecuci√≥n de la funci√≥n.

### C06 Key Personalizada
En el localStorage nuestros datos almacenados poseen una `key`, lo ideal ser√≠a mantener una `key` personalizada

Este c√≥digo posee una key `hardcodeada` directamente en los m√©todos:
```typescript
localStorage.setItem("task", JSON.stringify(this.tasks)); // ‚ùå Fr√°gil (poco mantenible)
```

Una soluci√≥n ser√≠a crearla de la siguiente forma:
```typescript
private static readonly STORAGE_KEY = "kanban_tasks"; // ‚úÖ Key centralizada
```
Con este cambio:
- √ºnico punto de cambio: Si se necesita renombrar la key, se hace de un solo lugar.
- Legibilidad: Claridad sobre qu√© key se usa en toda la clase
- Evitar errores tipogr√°ficos: no se repita strings m√°gisocs ("tasks") en m√∫ltiples m√©todos. 

#### Convenciones para el nombre de una Key
- Especifico: Para una app evitar nombres gen√©ricos como "data" o "tasks"
- Incluya versi√≥n: (ej: `_v1`) Si se esperan cambios futuros en la estructura de datos.
- Prefico √∫nico: si el sistema tiene multiples m√≥duls (ej: kanban_tasks, kanban_settings)

Ejemplos de convenciones de nombre
```typescript
private static readonly STORAGE_KEY = "kanban_tasks_v1";  
private static readonly STORAGE_KEY = "myapp_tasks_2024";  
private static readonly STORAGE_KEY = "projectX_tasks";  
```

#### Key global o por usuario
Si el sistema maneja m√∫ltiples usuarios, se podr√≠a agregar un ID como `user_id`_
```typescript
export class TaskService {
    private readonly STORAGE_KEY: string; // Key din√°mica

    constructor(userId: string) {
        this.STORAGE_KEY = `kanban_tasks_${userId}`; // Ej: "kanban_tasks_john123"
    }
}
```

### 

###